# ============================================
# printer.cfg – Duender CoreXY 
# ============================================
 
 
[virtual_sdcard]
path: ~/printer_data/gcodes
 
# ----------------------------
# Drucker-Kinematik
# ----------------------------
[printer]
kinematics: corexy
max_velocity: 300
max_accel: 8000
max_z_velocity: 10
max_z_accel: 200
square_corner_velocity: 5.0
 
# ----------------------------
# Z-Tilt (3 Z-Spindeln, 300x300 Bett)
# Z-Stepper (stepper_z/z1/z2) werden in der M8P-CFG definiert
# ----------------------------
[z_tilt]
z_positions:
    30, 30        # vorne links Spindel
    270, 30       # vorne rechts Spindel
    150, 270      # hinten mittig Spindel
points:
    50, 50        # vorne links Probe
    250, 50       # vorne rechts Probe
    150, 250      # hinten mittig Probe
speed: 50
horizontal_move_z: 5
retries: 5
retry_tolerance: 0.01
 
# Hinweis:
# Eddy-spezifische Probe-Definition (mcu eddy, probe_eddy_current, bed_mesh,
# PROBE_EDDY_CURRENT_CALIBRATE_AUTO etc.) kommt vollständig aus sample-bigtreetech-eddy.cfg.
 
# ----------------------------
# Z Bottom Homing Macro
# (alle Z-Motoren nach unten auf mechanischen Anschlag)
# ----------------------------
[gcode_macro Z_BOTTOM_HOMING]
description: "Fahre Z komplett nach unten und setze Z=0 (mechanischer Nullpunkt)"
gcode:
    G91
    G1 Z-5 F6000
    G1 Z-500 F600      # alle Z-Stepper nach unten, Wert bei Bedarf anpassen
    G90
    SET_POSITION Z=0
    M84 S0             # Z-Stepper nicht sofort deaktivieren
 
# ----------------------------
# Z Safe Probe + Z-Tilt (Eddy übernimmt Z-Homing)
# ----------------------------
[gcode_macro Z_SAFE_PROBE]
description: "Sicher hochfahren, Z homen und Z_TILT_ADJUST mit Eddy"
gcode:
    G91
    G1 Z10 F6000       # relativ Z hoch
    G90
    G28 Z              # Z-Homing über Eddy (G28 ist in Eddy-CFG umdefiniert)
    Z_TILT_ADJUST
 
# ----------------------------
# START_PRINT Macro
# (ohne S-Parameter-Parsing für einfache Integration in Slicer)
# ----------------------------
[gcode_macro START_PRINT]
description: "Startsequenz mit Bottom-Homing, Z-Tilt und Aufheizen"
gcode:
    # Optional: Parameter übernehmen (z.B. aus Slicer)
    {% set BED = params.BED|default(60)|float %}
    {% set HOTEND = params.HOTEND|default(200)|float %}
 
    # Z nach unten referenzieren
    Z_BOTTOM_HOMING
 
    # XY homen (sensorless, in M8P-CFG hinterlegt)
    G28 X Y
 
    # Bett etwas hochfahren und zur Mitte
    G1 Z10 F6000
    G1 X{ printer.toolhead.axis_maximum.x/2 } \
       Y{ printer.toolhead.axis_maximum.y/2 } F6000
 
    # Z über Eddy homen + Z-Tilt
    Z_SAFE_PROBE
 
    # Bett aufheizen
    M140 S{BED}
    M190 S{BED}
 
    # Hotend aufheizen
    M104 S{HOTEND}
    M109 S{HOTEND}
 
    # Extruder nullen und optional primen
    G92 E0
    G1 F1200 E3
 
# ----------------------------
# END_PRINT Macro (einfaches Platzhalter-Ende)
# ----------------------------
[gcode_macro END_PRINT]
description: "Endsequenz: Kopf weg, Z hoch, Lüfter aus"
gcode:
    G91
    G1 Z10 F600        # Z hoch
    G1 X-20 Y-20 F6000 # etwas weg vom Druckteil
    G90
    M104 S0
    M140 S0
    M106 S0
    M84
 
# ----------------------------
# RESET_CAN Macro 
# ----------------------------
[gcode_macro RESET_CAN]
gcode:
    RUN_SHELL_COMMAND CMD="/usr/local/bin/reset_can.sh"
 
[pause_resume]
 
[gcode_macro PAUSE]
rename_existing: PAUSE_BASE
gcode:
  PAUSE_BASE
  {% if printer.extruder.can_extrude %} 
    TURN_OFF_HEATERS 
  {% endif %}
 
[gcode_macro RESUME]
rename_existing: RESUME_BASE
gcode:
  RESUME_BASE
 
[gcode_macro CANCEL_PRINT]
rename_existing: CANCEL_PRINT_BASE
gcode:
  TURN_OFF_HEATERS
  CANCEL_PRINT_BASE
 
[display_status]
 
# ----------------------------
# EBB36 
# ----------------------------
 
[mcu EBBCan]
#serial: /dev/serial/by-id/usb-Klipper_Klipper_firmware_12345-if00
canbus_uuid: 248db3d894f5
 
[board_pins EBB36_G0B1_v1.2]
aliases:
aliases_step:
    EXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15
aliases_limitsw: # these are preferred for endstops (including klicky)
    LIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6
aliases_bltouch: # these are the dupont connectors for bltouch
    PROBE_1=PB9,PROBE_2=PB8
aliases_fans:
    FAN0=PA1,FAN1=PA0
aliases_thermistors:
    TH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7
aliases_heaters:
    HE0=PA2
aliases_rgb:
    RGBLED=PD3
aliases_adxl:
    ADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11
aliases_i2c:
    AUX0=PB3,AUX1=PB4
 
[adxl345]
cs_pin: EBBCan: PB12
spi_bus: spi2_PB2_PB11_PB10
axes_map: x,y,z
 
[extruder]
step_pin: EBBCan: PD0
dir_pin: !EBBCan: PD1
enable_pin: !EBBCan: PD2
microsteps: 16
rotation_distance: 33.5
nozzle_diameter: 0.4
filament_diameter: 1.75
heater_pin: EBBCan: PB13
 
sensor_type: MAX31865
sensor_pin: EBBCan: PA4      # passender CS-Pin für dein MAX31865-Slot
spi_bus: spi1
rtd_nominal_r: 1000          # PT1000
rtd_reference_r: 4300
rtd_num_of_wires: 2
 
control: pid
pid_kp: 21.527
pid_ki: 1.063
pid_kd: 108.982
min_temp: 0
max_temp: 350
 
 
[tmc2209 extruder]
uart_pin: EBBCan: PA15
run_current: 0.650
stealthchop_threshold: 999999
 
[fan]
pin: EBBCan: PA1
 
[heater_fan hotend_fan]
pin: EBBCan: PA0
heater: extruder
heater_temp: 50.0
 
[neopixel hotend_rgb]
pin: EBBCan:PD3
 
 
# ============================================
# Eddy USB – angepasste Config für 300x300
# ============================================
 
# The MCU section only applies to the Eddy USB. For Eddy Coil you will use the MCU name of the toolboard that you connected the Eddy Coil to.
[mcu eddy]
canbus_uuid: 10afd2d612d2

[temperature_sensor btt_eddy_mcu]
sensor_type: temperature_mcu # Sets the type of sensor for Klipper to read
sensor_mcu: eddy # Sets the MCU of the eddy probe tempereature sensor
min_temp: 10 # Sets the minimum tempereature for eddys tempereature sensor to operate
max_temp: 100 # Sets the maximum tempereature for eddys tempereature sensor to operate

[probe_eddy_current btt_eddy]
sensor_type: ldc1612
z_offset: 2.5
#i2c_address:
i2c_mcu: eddy  # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the MCU you have used.
i2c_bus: i2c0f # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the I2C bus you have used.
# Measure the offsets below using the method described here: https://www.klipper3d.org/Probe_Calibrate.html#calibrating-probe-x-and-y-offsets
# For a standard Voron stealthburner X carriage mount there should be no need to change the defaults below.
x_offset: 0
y_offset: 25

# This section is only relevant for Eddy USB. Comment it out for Eddy Coil.
[temperature_probe btt_eddy]
sensor_type: Generic 3950
sensor_pin: eddy:gpio26
horizontal_move_z: 2

[bed_mesh]
horizontal_move_z: 2
speed: 200
# For the mesh dimensions below, the coordinates need to be reachable by the center of the probe. To calculate coordinates that will work, use the formula below:
# mesh x min = position_min_x + greater_of (15mm or x_offset) <--- in this term, only consider the x offset if it is positive, ignore if negative.
# mesh y min = position_min_y + greater_of (15mm or y_offset) <--- in this term, only consider the y offset if it is positive, ignore if negative.
# mesh x max = position_max_x - greater_of (15mm or |x_offset|) <--- in this term, only consider the x offset if it is negative, ignore if positive.
# mesh y max = position_max_y - greater_of (15mm or |y_offset|) <--- in this term, only consider the y offset if it is negative, ignore if positive.
# Example: Consider that you have a 300 x 300 bed with the max x and y positions being 300 and the min being 0. Your probe offsets are -20 for X and 10 for Y
# For mesh x min we ignore the x offset term because it is negative. Therefore mesh x min = 15
# For mesh y min we do not ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y min = 15
# For mesh x max we do not ignore the x offset term because it is negative. It is also greater than 15. Therefore mesh x max = 280
# For mesh y max we ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y max = 285
# The final result would be mesh_min: 15, 15 mesh_max: 280, 285
mesh_min: 30, 30  # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
mesh_max: 270, 270 # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
probe_count: 9, 9
algorithm: bicubic
#scan_overshoot: 8  #uncomment this section if you still have room left over on the X axis for some scan overshoot to product smoother movements and more accurate scanning. Uncommenting this should be fine if you are using a standard voron mount.

# Uncomment this if you are using Eddy as the probe AND the homing endstop
[safe_z_home]
home_xy_position: 150, 150 # Choose an X,Y position that is in the center of your bed. For a 300x300 machine that will be 150, 150. Use the same principle to calculate your bed center.
z_hop: 10
z_hop_speed: 25
speed: 200

###############################Macros and related################################
#This secton contains macros and related config sections. Some should be used, others are optional. Read the comment above each one to find out whether or not to uncomment it for your installation.


# Uncomment this if you are using Eddy as the probe AND the homing endstop AND would like to use the beta z-offset control
[save_variables]
filename: ~/printer_data/config/variables.cfg



# Uncomment this if you are using Eddy as the probe AND the homing endstop
[force_move]
enable_force_move: True # Allows a user to move the z axis down if they have no other means of homing Z and need to calibrate the Eddy.



# Uncomment this if you are using Eddy as the probe AND the homing endstop AND would like to use the beta z-offset control
[delayed_gcode RESTORE_PROBE_OFFSET]
initial_duration: 1.
gcode:
  {% set svv = printer.save_variables.variables %}
  {% if not printer["gcode_macro SET_GCODE_OFFSET"].restored %}
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE={ svv.nvm_offset|default(0) }
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=restored VALUE=True
  {% endif %}



# Uncomment this if you are using Eddy as the probe AND the homing endstop
# Take note of the lines that should only be used if you have a KNOMI installed.
[gcode_macro G28]
rename_existing: G28.1
gcode:
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=homing VALUE=True # Uncomment this if using a KNOMI and then remove the G28 macro from the KNOMI.cfg
  G28.1 {rawparams}
  {% if not rawparams or (rawparams and 'Z' in rawparams) %}
    PROBE
    SET_Z_FROM_PROBE
  {% endif %}
  #SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=homing VALUE=False # Uncomment this if using a KNOMI and then remove the G28 macro from the KNOMI.cfg



# Uncomment this if you are using Eddy as the probe AND the homing endstop
[gcode_macro SET_Z_FROM_PROBE]
gcode:
    {% set cf = printer.configfile.settings %}
    SET_GCODE_OFFSET_ORIG Z={printer.probe.last_z_result - cf['probe_eddy_current btt_eddy'].z_offset + printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset}
    G90
    G1 Z{cf.safe_z_home.z_hop}


# Uncomment this if you are using Eddy as the probe AND the homing endstop AND would like to use the beta z-offset control
[gcode_macro Z_OFFSET_APPLY_PROBE]
rename_existing: Z_OFFSET_APPLY_PROBE_ORIG
gcode:
  SAVE_VARIABLE VARIABLE=nvm_offset VALUE={ printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset }



# Uncomment the lines in this macro if you are using Eddy as the probe AND the homing endstop AND would like to use the beta z-offset control
[gcode_macro SET_GCODE_OFFSET]
rename_existing: SET_GCODE_OFFSET_ORIG
variable_restored: False  # Mark whether the var has been restored from NVM
variable_runtime_offset: 0
gcode:
  {% if params.Z_ADJUST %}
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE={ printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset + params.Z_ADJUST|float }
  {% endif %}
  {% if params.Z %} 
    {% set paramList = rawparams.split() %}
    {% for i in range(paramList|length) %}
      {% if paramList[i]=="Z=0" %}
        {% set temp=paramList.pop(i) %}
        {% set temp="Z_ADJUST=" + (-printer["gcode_macro SET_GCODE_OFFSET"].runtime_offset)|string %}
        {% if paramList.append(temp) %}{% endif %}
      {% endif %}
    {% endfor %}
    {% set rawparams=paramList|join(' ') %}
    SET_GCODE_VARIABLE MACRO=SET_GCODE_OFFSET VARIABLE=runtime_offset VALUE=0
  {% endif %}
  SET_GCODE_OFFSET_ORIG { rawparams }



# This macro automates a lot of the frequency mapping process and simplifies the steps significantly.
[gcode_macro PROBE_EDDY_CURRENT_CALIBRATE_AUTO]
gcode:
  BED_MESH_CLEAR
  G28 X Y
  G90 # Abs positioning
  G1 X{ printer.toolhead.axis_maximum.x/2 } Y{ printer.toolhead.axis_maximum.y/2 } F6000
  {% if 'z' not in printer.toolhead.homed_axes %}
    SET_KINEMATIC_POSITION Z={ printer.toolhead.axis_maximum.z-1 } # Allows the user to work it down until it touches.
  {% endif %}
  PROBE_EDDY_CURRENT_CALIBRATE {rawparams}



#This macro is optional but useful if you want to run a rapid scan before each print. Simply uncomment it and add BED_MESH_SCAN to your print start code.
#[gcode_macro BED_MESH_CALIBRATE]
#rename_existing: BTT_BED_MESH_CALIBRATE
#gcode:
#  SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=True #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
#  BTT_BED_MESH_CALIBRATE METHOD=rapid_scan
#  SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=False #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
 
# ----------------------------
# M8P V2 
# ----------------------------
 
 
# Motor1
[stepper_x]
step_pin: PE6
dir_pin: PE5
enable_pin: !PC14
microsteps: 16
rotation_distance: 40
endstop_pin: tmc2209_stepper_x:virtual_endstop
position_endstop: 0
position_max: 235
homing_speed: 50
 
 
# Motor2
[stepper_y]
step_pin: PE2
dir_pin: PE1
enable_pin: !PE4
microsteps: 16
rotation_distance: 40
endstop_pin: tmc2209_stepper_y:virtual_endstop
position_endstop: 0
position_max: 235
homing_speed: 50
 
# Motor3
[stepper_z]
step_pin: PB8
dir_pin: !PB7
enable_pin: !PE0
microsteps: 16
rotation_distance: 8
endstop_pin: !PF2
position_endstop: 0
position_max: 410
position_min: -15.0
homing_speed: 8
second_homing_speed: 3
homing_retract_dist: 3
homing_positive_dir: false
 
# Motor4
[stepper_z1]
step_pin: PB4
dir_pin: !PB3
enable_pin: !PB6
microsteps: 16
rotation_distance: 8

 
# Motor5
[stepper_z2]
step_pin: PG13
dir_pin: !PG12
enable_pin: PG15
microsteps: 16
rotation_distance: 8

 
########################################
# TMC2226 configuration (KORRIGIERT!)
########################################
 
[tmc2209 stepper_x]
uart_pin: PC13
diag_pin: PF4 
run_current: 1
stealthchop_threshold: 999999
driver_SGTHRS: 60
 
# Motor2
[tmc2209 stepper_y]
uart_pin: PE3
diag_pin: PF3
run_current: 1
stealthchop_threshold: 999999
driver_SGTHRS: 60
 
# Motor3
[tmc2209 stepper_z]
uart_pin: PB9
#diag_pin: PF2
run_current: 0.8
stealthchop_threshold: 999999
 
# Motor4
[tmc2209 stepper_z1]
uart_pin: PB5
#diag_pin: PF1
run_current: 0.8
stealthchop_threshold: 999999
 
# Motor5
[tmc2209 stepper_z2]
uart_pin: PG14
run_current: 0.8
stealthchop_threshold: 999999
 
 
## End-Stop 5
#[filament_switch_sensor material_0]
#switch_pin: PF0
 
## Motor6
#[extruder1]
#step_pin: PG9
#dir_pin: PD7
#enable_pin: !PG11 
#heater_pin: PA1 # HE1 
#sensor_pin: PC5 # T1
#...
 
## End-Stop 6
#[filament_switch_sensor material_1]
#switch_pin: PC15
 
## Motor7
#[extruder2]
#step_pin: PD4
#dir_pin: PD3
#enable_pin: !PD6
#heater_pin: PA3 # HE2
#sensor_pin: PC4 # T2
#...
 
## Motor8
#[extruder3]
#step_pin: PC7
#dir_pin: PC8
#enable_pin: !PD2
#heater_pin: PA5 # HE3
#sensor_pin: PA7 # T3
#...
 
[heater_bed]
heater_pin: PF5
sensor_pin: PB0 # TB 
sensor_type: ATC Semitec 104GT-2
control: watermark
min_temp: 0
max_temp: 130
 
#[fan_generic soc-fan]
#pin: host:gpio79  #CB1
#pin: host:gpio26  #CM4
 
# Fan0
[fan]
pin: PF7
 
## Fan1
#[heater_fan fan1]
#pin: PF9
 
## Fan2
#[heater_fan fan2]
#pin: PF6
 
## Fan3
#[heater_fan fan3]
#pin: PF8
 
## Fan4
#[heater_fan fan4]
#pin: PA4
 
## Fan5
#[heater_fan fan5]
#pin: PA6
#tachometer_pin: PC2
 
## Fan6
#[heater_fan fan6]
#pin: PA2
#tachometer_pin: PC1
 
[mcu]
#serial: /dev/serial/by-id/usb-Klipper_stm32h723xx_4C002C000F51313531383332-if00
canbus_uuid: 7a8f1f811139 
 
[board_pins]
aliases:
    # EXP1 header
    EXP1_1=PE7, EXP1_2=PG1,
    EXP1_3=PG0, EXP1_4=PF15,
    EXP1_5=PF14, EXP1_6=PF13,    # Slot in the socket on this side
    EXP1_7=PF12, EXP1_8=PF11,
    EXP1_9=<GND>, EXP1_10=<5V>,
 
    # EXP2 header
    EXP2_1=PE13, EXP2_2=PE12,
    EXP2_3=PE15, EXP2_4=PE11,
    EXP2_5=PE10, EXP2_6=PE14,      # Slot in the socket on this side
    EXP2_7=PE8, EXP2_8=<RST>,
    EXP2_9=<GND>, EXP2_10=<NC>
 
# See the sample-lcd.cfg file for definitions of common LCD displays.
 
#[adxl345]
#cs_pin: PA15
#spi_bus: spi3a
 
#[bltouch]
#sensor_pin: PD13
#control_pin: PD12
 
## Proximity switch
#[probe]
#pin: PD8
 
#[output_pin ps_on_pin]
#pin: PD14
 
#[neopixel my_neopixel_1]
#pin: PD15
 
#[hall_filament_width_sensor]
#adc1: PC0
#adc2: PF10

#*# <---------------------- SAVE_CONFIG ---------------------->
#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.
#*#
#*# [probe_eddy_current btt_eddy]
#*# reg_drive_current = 15
